{"./":{"url":"./","title":"介绍","keywords":"","body":"要像星星一样发光 bling bling "},"SUMMARY.html":{"url":"SUMMARY.html","title":"目录","keywords":"","body":"Summary 介绍 目录 ES6 let和const命令 VUE 基础语法 Vue条件渲染及列表渲染 Vue组件 介绍及语法特点 强制绑定class和style 计算属性 微信小程序 算法 基础知识 时间复杂度 面试 金谷面试题 "},"ES6/":{"url":"ES6/","title":"ES6","keywords":"","body":""},"ES6/let和const命令.html":{"url":"ES6/let和const命令.html","title":"let和const命令","keywords":"","body":"let和const命令 let 用法类似于var，但是声明的变量只在let命令所在的代码块内有效 { let a = 1; var b = 1; } console.log(a) // 报错 a is not defined console.log(b) // 1 不存在变量提升​ 就是说变量调用要在声明之后，var存在变量提升 暂时性死区:star: 在代码块中使用let，即使全局有相同变量被var声明，代码块中的变量也不会被全局所影响 不允许重复声明​ 不能在同一作用域中重复声明 块级作用域​ 什么情况下需要块级作用域？ // 内层变量可能会覆盖外层变量 var tmp = new Date(); function f() { console.log(tmp); if (false) { var tmp = \"hello world\"; } } f(); // undefined // 用来计数的循环变量泄露为全局变量 var s = 'hello'; for (var i = 0; i ES6的块级作用域 function f1() { // 块 let n = 5; if (true) { // 块 let n = 10; } console.log(n); // 5 } 上面代码存在两个代码块，都声明了n，但是外层不会被内层影响，所以最后console得到5。 块作用域的出现，立即执行函数表达式大可不必了。（因为立即执行函数的作用就是避免污染全局，形成一个单独的作用域） const const声明一个只读的变量（一旦声明立即赋值，不能更改，只声明不赋值会报错） 和let一样不可重复声明，只在块级作用域内作用，不存在变量提升 对于复合类型的对象，变量名指向地址，const只是保证变量名指向的地址不变，并不保证该地址的数据不变。 const foo = {}; foo.prop = 123; foo.prop // 123 foo = {}; // TypeError: \"foo\" is read-only 顶层对象 ES5中顶层对象是window，var和function定义的全局变量可使用window调用 ES6中，使用let和const定义的全局变量虽然是全局使用的，但是使用window调用会undefined 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。 "},"VUE/":{"url":"VUE/","title":"VUE","keywords":"","body":"Vue "},"VUE/基础语法/":{"url":"VUE/基础语法/","title":"基础语法","keywords":"","body":""},"VUE/基础语法/Vue条件渲染及列表渲染.html":{"url":"VUE/基础语法/Vue条件渲染及列表渲染.html","title":"Vue条件渲染及列表渲染","keywords":"","body":"Vue条件渲染及列表渲染 :lion: 条件渲染 :lion: v-if v-else控制元素显示隐藏（控制节点渲染，即这个节点在页面树中是否存在） v-show通过style方式进行隐藏，节点会被渲染 列表渲染 :lion: 使用v-for进行一个数据集的列表渲染，需要使用item in items形式的特殊语法，items是原数组数据，item为别名 变异方法（可更新视图） push: 结尾添加数据，返回数组长度 pop: 删除结尾最后一条数据，并返回它 shift: 删除第一条数据，并返回它 unshift: 向开头添加一个或多个数据，返回数组长度 splice: 向数组中添加/删除数据，返回被删除的数据 sort: 对数组进行排序（在原数组上执行） reverse: 对数组进行反转（在原数组上执行） "},"VUE/基础语法/Vue组件.html":{"url":"VUE/基础语法/Vue组件.html","title":"Vue组件","keywords":"","body":"Vue组件 :lion: 组件是可复用的Vue实例，在Vue根实例中可以把组件作为自定义元素来使用。 组件中的data必须是一个函数 // 页面中 data: { count: 0 } // 组件中 data: function () { return { count: 0 } } 组件名 :lion: 命名方式有两种 kebab-case PascalCase 全局注册 :lion: 好处是在任何新创建的Vue的根实例中使用 局部注册 :lion: 全局注册在模块式开发时，意味着你已经不再使用一个组件了，它会被包含在最终的构建结果中（即使你不使用一样会被加载）。造成了用户下载JavaScript的负担。 局部注册的组件在其子组件中不可用，可以使用import来引入。 prop :lion: 由于HTML中对于标签名大小写是不敏感的，所以一般使用kebab-case命名方式。 prop类型 :lion: "},"VUE/基础语法/介绍及语法特点.html":{"url":"VUE/基础语法/介绍及语法特点.html","title":"介绍及语法特点","keywords":"","body":"Vue介绍及语法特点 :lion: Vue是渐进式Javascript框架，何为渐进式？ :lion: 个人理解不会限制你的思想，可以和Augular对比一下，对于Angular来说必须使用它的模块机制，必须使用它的依赖注入，必须使用它的它的特殊形式定义组件。 但是Vue可以在原有系统上把一两个组件改用它实现，当作Jquery用；也可以整个用它全家桶开发，当Augular用；还可以用他的视图搭配你自己设计的整个下层用。 MVVM模式 :lion: View 视图 -----> DOM监听Model view 视图 即view与Model之间通过ViewModel连接，实现数据的双向绑定 Vue的双向绑定原理 :lion: Vue的双向绑定是通过数据劫持开发者-订阅者的方式 data () { return { obj : { a: 1 } } }, created(){ console.log(this.obj); }, 根据图片所示，我们可以看到a属性有get和set方法，因为Vue是通过Object.defineProperty()来实现数据劫持的。它可以来控制一个对象属性的一些特有操作。 简单点说，get就是在读取属性的时候触发的函数，set就是在设置属性的时候触发的函数。 模板语法 :lion: 在HTML代码中，使用{{}}来包裹js代码以达到数据在html页面中显示的目的。 "},"VUE/基础语法/强制绑定class和style.html":{"url":"VUE/基础语法/强制绑定class和style.html","title":"强制绑定class和style","keywords":"","body":"Vue强制绑定class和style :lion: class :lion: 正常赋值字符串 赋值数组 ['xxx','aaa'] 赋值对象 {aClass: true, bClass: true} 使用数组或对象时要在前面加上v-bind或使用语法糖 : style :lion: 使用对象 “{color：activeColor，fontSize：fontSize+‘px’}”activeColor和fontSize为data中的属性 "},"VUE/基础语法/计算属性.html":{"url":"VUE/基础语法/计算属性.html","title":"计算属性","keywords":"","body":"计算属性 :lion: computed :lion: 在初始化显示的时候执行一次，之后在相关数据变化时才会执行。 computed:{ fullName1(){ //计算属性中的一个方法，方法的返回值作为属性值 return this.firstName + \" \" + this.lastName; }, fullName3:{ //回调函数三个条件：你定义的，你没有调用，但最终执行了 //回调函数什么时候调用？用来干嘛的？ //回调函数 当需要读取当前属性值时回调 根据相关的数据计算并返回当前属性的值 get(){ return this.firstName + \" \" + this.lastName; }, //回调函数，监视当前属性值的变化，当属性值发生改变时回调，更新相关的属性数据 set(value){ //value就是fullName3的最新属性值 const names = value.split(' '); this.firstName = names[0]; this.lastName = names[1]; } } }, 特点： 支持缓存 不支持异步 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一对多或一对一，一般用computed 如果computed属性值是函数，默认会走get方法，函数的返回值就是属性的属性值。 watch :lion: 特点： 不支持缓存，数据变化直接触发 支持异步 接收两个参数，一个是最新的值，一个是修改前的值 当一个属性发生变化时，执行对应操作，一对多 监听数据必须是data中声明过或者是props中的数据。函数有两个参数 immediate 组件加载立即触发回调 deep 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用。但是对于数组变动不能这样做。deep无法监听数组的变动和对象的新增，只能以响应式的方式触发才会被监听到。 $set :lion: 利用Vue中的set让修改内容的数组或者对象渲染到页面中，如果不用这种方法，数据被修改了，但是不会渲染到视图 this.$set(数组或者对象，修改的下标或者对象属性名，修改的值) 但是修改数组中的对象，或者对象中的对象是不用$set的 "},"微信小程序/":{"url":"微信小程序/","title":"微信小程序","keywords":"","body":""},"算法/":{"url":"算法/","title":"算法","keywords":"","body":""},"算法/基础知识/":{"url":"算法/基础知识/","title":"基础知识","keywords":"","body":""},"算法/基础知识/时间复杂度.html":{"url":"算法/基础知识/时间复杂度.html","title":"时间复杂度","keywords":"","body":"时间复杂度 "},"面试/":{"url":"面试/","title":"面试","keywords":"","body":""},"面试/金谷面试题.html":{"url":"面试/金谷面试题.html","title":"金谷面试题","keywords":"","body":"初中级前端面试 :lion: JS :lion: 什么是闭包？闭包的特性是什么？ 闭包其实只是一个绑定了执行环境的函数 闭包的特性 :lion: 1.封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口； 2.持久性：一般的函数，调用完之后，系统会自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包依然存在。 解释下变量提升 :lion: JavaScript引擎的作式是，先解析代码，获取所有被声明的变量，然后再运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升 promise :lion: 一共有三种状态，分别为pending（进行中）、resolved（已成功）和rejected（已失败）。 数组去重方法 :lion: let arr = [1,0,0,2,9,8,3,1]; 2 function unique(arr) { 3 return Array.from(new Set(arr)) 4 } var arr = [1, 5, 6, 0, 7, 3, 0, 5, 9,5,5]; function unique(arr) { for (var i = 0, len = arr.length; i 箭头函数 :lion: 箭头函数是匿名函数，不能作为构造函数，不能使用new 箭头函数不绑定arguments，取而代之用rest参数...解决 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值 箭头函数没有原型属性 "}}