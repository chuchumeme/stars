# 计算属性 :lion:

#### computed :lion:

在初始化显示的时候执行一次，之后在相关数据变化时才会执行。

```js
computed:{          
  fullName1(){  //计算属性中的一个方法，方法的返回值作为属性值
    return this.firstName + " " + this.lastName;
  },
    fullName3:{
      //回调函数三个条件：你定义的，你没有调用，但最终执行了
      //回调函数什么时候调用？用来干嘛的？
      //回调函数 当需要读取当前属性值时回调 根据相关的数据计算并返回当前属性的值
      get(){
        return this.firstName + " " + this.lastName;
      },
        //回调函数，监视当前属性值的变化，当属性值发生改变时回调，更新相关的属性数据
        set(value){
          //value就是fullName3的最新属性值
          const names = value.split(' ');
          this.firstName = names[0];
          this.lastName = names[1];
        }
    }
},
```

特点：

- 支持缓存
- 不支持异步
- 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一对多或一对一，一般用computed
- 如果computed属性值是函数，默认会走get方法，函数的返回值就是属性的属性值。

#### watch :lion:

特点：

- 不支持缓存，数据变化直接触发
- 支持异步
- 接收两个参数，一个是最新的值，一个是修改前的值
- 当一个属性发生变化时，执行对应操作，一对多
- 监听数据必须是data中声明过或者是props中的数据。函数有两个参数
  - immediate 组件加载立即触发回调
  - deep 深度监听，为了发现**对象内部值**的变化，复杂类型的数据时使用。但是对于数组变动不能这样做。deep无法监听数组的变动和对象的新增，只能以响应式的方式触发才会被监听到。

#### $set :lion:

利用Vue中的set让修改内容的数组或者对象渲染到页面中，如果不用这种方法，数据被修改了，但是不会渲染到视图

this.$set(数组或者对象，修改的下标或者对象属性名，修改的值)

但是修改数组中的对象，或者对象中的对象是不用$set的